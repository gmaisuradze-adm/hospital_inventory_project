/**
 * Additional controller methods to implement all route handlers
 * This file includes all missing methods that need to be added to controllers.js
 */

// Get a single report template by ID
exports.getReportTemplateById = async (req, res) => {
  try {
    const { id } = req.params;
    
    const template = await ReportTemplate.findByPk(id, {
      include: [{
        model: sequelize.models.user,
        as: 'creator',
        attributes: ['id', 'username', 'firstName', 'lastName']
      }]
    });
    
    if (!template) {
      return res.status(404).json({
        success: false,
        error: 'Report template not found'
      });
    }
    
    // Check if user has access (private templates are only visible to creator or admin)
    if (!template.isPublic && 
        template.creatorId !== req.user.id && 
        !req.user.roles.includes('admin')) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to access this template'
      });
    }
    
    res.status(200).json({
      success: true,
      data: template
    });
  } catch (error) {
    console.error('Error fetching report template:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Update a report template
exports.updateReportTemplate = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, type, config, isPublic } = req.body;
    
    const template = await ReportTemplate.findByPk(id);
    if (!template) {
      return res.status(404).json({
        success: false,
        error: 'Report template not found'
      });
    }
    
    // Check if user has permission
    if (template.creatorId !== req.user.id && !req.user.roles.includes('admin')) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to update this template'
      });
    }
    
    // Update template fields
    await template.update({
      name: name || template.name,
      description: description !== undefined ? description : template.description,
      type: type || template.type,
      config: config || template.config,
      isPublic: isPublic !== undefined ? isPublic : template.isPublic
    });
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'report_template_updated',
      entityType: 'report_template',
      entityId: template.id,
      description: `Report template "${template.name}" updated`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      data: template
    });
  } catch (error) {
    console.error('Error updating report template:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete a report template
exports.deleteReportTemplate = async (req, res) => {
  try {
    const { id } = req.params;
    
    const template = await ReportTemplate.findByPk(id);
    if (!template) {
      return res.status(404).json({
        success: false,
        error: 'Report template not found'
      });
    }
    
    // Check if user has permission
    if (template.creatorId !== req.user.id && !req.user.roles.includes('admin')) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to delete this template'
      });
    }
    
    // Store template name for audit log
    const templateName = template.name;
    
    // Delete template
    await template.destroy();
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'report_template_deleted',
      entityType: 'report_template',
      entityId: id,
      description: `Report template "${templateName}" deleted`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      message: 'Report template deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting report template:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get all saved reports for current user
exports.getSavedReports = async (req, res) => {
  try {
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Build query conditions
    let where = {};
    if (!isAdmin) {
      where.creatorId = userId;
    }
    
    if (req.query.templateId) {
      where.reportTemplateId = req.query.templateId;
    }
    
    const reports = await SavedReport.findAll({
      where,
      include: [
        {
          model: ReportTemplate,
          attributes: ['id', 'name', 'type']
        },
        {
          model: sequelize.models.user,
          as: 'creator',
          attributes: ['id', 'username', 'firstName', 'lastName']
        }
      ],
      order: [['generatedDate', 'DESC']]
    });
    
    res.status(200).json({
      success: true,
      data: reports
    });
  } catch (error) {
    console.error('Error fetching saved reports:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get a single saved report by ID
exports.getSavedReportById = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const report = await SavedReport.findByPk(id, {
      include: [
        {
          model: ReportTemplate,
          attributes: ['id', 'name', 'type', 'config']
        },
        {
          model: sequelize.models.user,
          as: 'creator',
          attributes: ['id', 'username', 'firstName', 'lastName']
        }
      ]
    });
    
    if (!report) {
      return res.status(404).json({
        success: false,
        error: 'Saved report not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && report.creatorId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to view this report'
      });
    }
    
    res.status(200).json({
      success: true,
      data: report
    });
  } catch (error) {
    console.error('Error fetching saved report:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete a saved report
exports.deleteSavedReport = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const report = await SavedReport.findByPk(id);
    if (!report) {
      return res.status(404).json({
        success: false,
        error: 'Saved report not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && report.creatorId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to delete this report'
      });
    }
    
    // Store report name for audit log
    const reportName = report.name;
    
    // Delete report
    await report.destroy();
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'saved_report_deleted',
      entityType: 'saved_report',
      entityId: id,
      description: `Saved report "${reportName}" deleted`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      message: 'Saved report deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting saved report:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Create a new dashboard
exports.createDashboard = async (req, res) => {
  try {
    const { name, description, isDefault } = req.body;
    const ownerId = req.user.id;
    
    // Check if a default dashboard already exists for this user
    if (isDefault) {
      const existingDefault = await Dashboard.findOne({
        where: {
          ownerId,
          isDefault: true
        }
      });
      
      if (existingDefault) {
        // Remove default status from existing dashboard
        await existingDefault.update({ isDefault: false });
      }
    }
    
    const dashboard = await Dashboard.create({
      name,
      description,
      layout: [],
      isDefault: isDefault || false,
      ownerId
    });
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_created',
      entityType: 'dashboard',
      entityId: dashboard.id,
      description: `Dashboard "${name}" created`,
      userId: ownerId,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(201).json({
      success: true,
      data: dashboard
    });
  } catch (error) {
    console.error('Error creating dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get all dashboards for current user
exports.getDashboards = async (req, res) => {
  try {
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Build query conditions
    let where = {};
    if (!isAdmin) {
      where.ownerId = userId;
    }
    
    const dashboards = await Dashboard.findAll({
      where,
      include: [{
        model: sequelize.models.user,
        as: 'owner',
        attributes: ['id', 'username', 'firstName', 'lastName']
      }],
      order: [['createdAt', 'DESC']]
    });
    
    res.status(200).json({
      success: true,
      data: dashboards
    });
  } catch (error) {
    console.error('Error fetching dashboards:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get a single dashboard by ID with widgets
exports.getDashboardById = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const dashboard = await Dashboard.findByPk(id, {
      include: [
        {
          model: sequelize.models.user,
          as: 'owner',
          attributes: ['id', 'username', 'firstName', 'lastName']
        },
        {
          model: DashboardWidget,
          as: 'widgets'
        }
      ]
    });
    
    if (!dashboard) {
      return res.status(404).json({
        success: false,
        error: 'Dashboard not found'
      });
    }
    
    // Check if user has permission to view dashboard
    if (!isAdmin && dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to view this dashboard'
      });
    }
    
    res.status(200).json({
      success: true,
      data: dashboard
    });
  } catch (error) {
    console.error('Error fetching dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Update a dashboard
exports.updateDashboard = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, description, layout, isDefault } = req.body;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const dashboard = await Dashboard.findByPk(id);
    if (!dashboard) {
      return res.status(404).json({
        success: false,
        error: 'Dashboard not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to update this dashboard'
      });
    }
    
    // If setting this dashboard as default, remove default from other dashboards
    if (isDefault && !dashboard.isDefault) {
      const existingDefault = await Dashboard.findOne({
        where: {
          ownerId: userId,
          isDefault: true,
          id: { [Sequelize.Op.ne]: id }
        }
      });
      
      if (existingDefault) {
        await existingDefault.update({ isDefault: false });
      }
    }
    
    // Update dashboard fields
    await dashboard.update({
      name: name || dashboard.name,
      description: description !== undefined ? description : dashboard.description,
      layout: layout || dashboard.layout,
      isDefault: isDefault !== undefined ? isDefault : dashboard.isDefault
    });
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_updated',
      entityType: 'dashboard',
      entityId: dashboard.id,
      description: `Dashboard "${dashboard.name}" updated`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      data: dashboard
    });
  } catch (error) {
    console.error('Error updating dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete a dashboard
exports.deleteDashboard = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const dashboard = await Dashboard.findByPk(id);
    if (!dashboard) {
      return res.status(404).json({
        success: false,
        error: 'Dashboard not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to delete this dashboard'
      });
    }
    
    // Store dashboard name for audit log
    const dashboardName = dashboard.name;
    
    // Delete dashboard and its widgets
    await dashboard.destroy();
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_deleted',
      entityType: 'dashboard',
      entityId: id,
      description: `Dashboard "${dashboardName}" deleted`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      message: 'Dashboard deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Add a widget to a dashboard
exports.addWidgetToDashboard = async (req, res) => {
  try {
    const { dashboardId } = req.params;
    const { type, title, dataSource, params, refreshInterval, position } = req.body;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Check if dashboard exists and user has permission
    const dashboard = await Dashboard.findByPk(dashboardId);
    if (!dashboard) {
      return res.status(404).json({
        success: false,
        error: 'Dashboard not found'
      });
    }
    
    if (!isAdmin && dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to modify this dashboard'
      });
    }
    
    // Create widget
    const widget = await DashboardWidget.create({
      type,
      title,
      dataSource,
      params: params || {},
      refreshInterval: refreshInterval || 60,
      position: position || { x: 0, y: 0, w: 6, h: 4 },
      dashboardId
    });
    
    // Update dashboard layout to include new widget
    let layout = dashboard.layout || [];
    layout.push({
      i: widget.id,
      x: position?.x || 0,
      y: position?.y || 0,
      w: position?.w || 6,
      h: position?.h || 4
    });
    
    await dashboard.update({ layout });
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_widget_added',
      entityType: 'dashboard_widget',
      entityId: widget.id,
      description: `Widget "${title}" added to dashboard "${dashboard.name}"`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(201).json({
      success: true,
      data: widget
    });
  } catch (error) {
    console.error('Error adding widget to dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Update a dashboard widget
exports.updateDashboardWidget = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, dataSource, params, refreshInterval, position } = req.body;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Find widget with dashboard to check permissions
    const widget = await DashboardWidget.findByPk(id, {
      include: [{
        model: Dashboard,
        attributes: ['id', 'ownerId', 'name', 'layout']
      }]
    });
    
    if (!widget) {
      return res.status(404).json({
        success: false,
        error: 'Widget not found'
      });
    }
    
    // Check permissions
    if (!isAdmin && widget.Dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to update this widget'
      });
    }
    
    // Update widget fields
    await widget.update({
      title: title || widget.title,
      dataSource: dataSource || widget.dataSource,
      params: params || widget.params,
      refreshInterval: refreshInterval || widget.refreshInterval,
      position: position || widget.position
    });
    
    // If position changed, update dashboard layout
    if (position) {
      let layout = widget.Dashboard.layout || [];
      const widgetLayoutIndex = layout.findIndex(item => item.i === id);
      
      if (widgetLayoutIndex >= 0) {
        layout[widgetLayoutIndex] = {
          ...layout[widgetLayoutIndex],
          x: position.x || layout[widgetLayoutIndex].x,
          y: position.y || layout[widgetLayoutIndex].y,
          w: position.w || layout[widgetLayoutIndex].w,
          h: position.h || layout[widgetLayoutIndex].h
        };
      }
      
      await widget.Dashboard.update({ layout });
    }
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_widget_updated',
      entityType: 'dashboard_widget',
      entityId: widget.id,
      description: `Widget "${widget.title}" updated on dashboard "${widget.Dashboard.name}"`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      data: widget
    });
  } catch (error) {
    console.error('Error updating dashboard widget:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete a dashboard widget
exports.deleteDashboardWidget = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Find widget with dashboard to check permissions
    const widget = await DashboardWidget.findByPk(id, {
      include: [{
        model: Dashboard,
        attributes: ['id', 'ownerId', 'name', 'layout']
      }]
    });
    
    if (!widget) {
      return res.status(404).json({
        success: false,
        error: 'Widget not found'
      });
    }
    
    // Check permissions
    if (!isAdmin && widget.Dashboard.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to delete this widget'
      });
    }
    
    // Update dashboard layout to remove widget
    let layout = widget.Dashboard.layout || [];
    layout = layout.filter(item => item.i !== id);
    
    await widget.Dashboard.update({ layout });
    
    // Store widget info for audit log before deleting
    const widgetTitle = widget.title;
    const dashboardName = widget.Dashboard.name;
    
    // Delete widget
    await widget.destroy();
    
    // Create audit log entry
    await AuditLog.create({
      eventType: 'dashboard_widget_removed',
      entityType: 'dashboard_widget',
      entityId: id,
      description: `Widget "${widgetTitle}" removed from dashboard "${dashboardName}"`,
      userId: req.user.id,
      ipAddress: req.ip,
      timestamp: currentDate
    });
    
    res.status(200).json({
      success: true,
      message: 'Widget deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting dashboard widget:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get audit logs
exports.getAuditLogs = async (req, res) => {
  try {
    const {
      eventType,
      entityType,
      entityId,
      userId,
      startDate,
      endDate,
      page = 1,
      limit = 20
    } = req.query;
    
    // Build query conditions
    const where = {};
    if (eventType) where.eventType = eventType;
    if (entityType) where.entityType = entityType;
    if (entityId) where.entityId = entityId;
    if (userId) where.userId = userId;
    
    // Date range filter
    if (startDate || endDate) {
      where.timestamp = {};
      if (startDate) where.timestamp[Sequelize.Op.gte] = new Date(startDate);
      if (endDate) where.timestamp[Sequelize.Op.lte] = new Date(endDate);
    }
    
    // Calculate pagination
    const offset = (page - 1) * limit;
    
    const logs = await AuditLog.findAndCountAll({
      where,
      include: [{
        model: sequelize.models.user,
        as: 'user',
        attributes: ['id', 'username', 'firstName', 'lastName']
      }],
      order: [['timestamp', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
    
    res.status(200).json({
      success: true,
      data: {
        logs: logs.rows,
        pagination: {
          total: logs.count,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(logs.count / limit)
        }
      }
    });
  } catch (error) {
    console.error('Error fetching audit logs:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Create a new alert subscription
exports.createAlertSubscription = async (req, res) => {
  try {
    const { alertType, conditions, notificationChannel } = req.body;
    const userId = req.user.id;
    
    const subscription = await AlertSubscription.create({
      alertType,
      conditions: conditions || {},
      notificationChannel: notificationChannel || 'email',
      isActive: true,
      subscriberId: userId
    });
    
    res.status(201).json({
      success: true,
      data: subscription
    });
  } catch (error) {
    console.error('Error creating alert subscription:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get alert subscriptions for current user
exports.getUserAlertSubscriptions = async (req, res) => {
  try {
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    // Build query conditions
    let where = {};
    if (!isAdmin || !req.query.userId) {
      where.subscriberId = userId;
    } else if (req.query.userId) {
      where.subscriberId = req.query.userId;
    }
    
    if (req.query.alertType) {
      where.alertType = req.query.alertType;
    }
    
    const subscriptions = await AlertSubscription.findAll({
      where,
      include: [{
        model: sequelize.models.user,
        as: 'subscriber',
        attributes: ['id', 'username', 'firstName', 'lastName']
      }],
      order: [['createdAt', 'DESC']]
    });
    
    res.status(200).json({
      success: true,
      data: subscriptions
    });
  } catch (error) {
    console.error('Error fetching alert subscriptions:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Update an alert subscription
exports.updateAlertSubscription = async (req, res) => {
  try {
    const { id } = req.params;
    const { conditions, notificationChannel, isActive } = req.body;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const subscription = await AlertSubscription.findByPk(id);
    if (!subscription) {
      return res.status(404).json({
        success: false,
        error: 'Alert subscription not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && subscription.subscriberId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to update this subscription'
      });
    }
    
    // Update subscription
    await subscription.update({
      conditions: conditions || subscription.conditions,
      notificationChannel: notificationChannel || subscription.notificationChannel,
      isActive: isActive !== undefined ? isActive : subscription.isActive
    });
    
    res.status(200).json({
      success: true,
      data: subscription
    });
  } catch (error) {
    console.error('Error updating alert subscription:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete an alert subscription
exports.deleteAlertSubscription = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const isAdmin = req.user.roles.includes('admin');
    
    const subscription = await AlertSubscription.findByPk(id);
    if (!subscription) {
      return res.status(404).json({
        success: false,
        error: 'Alert subscription not found'
      });
    }
    
    // Check if user has permission
    if (!isAdmin && subscription.subscriberId !== userId) {
      return res.status(403).json({
        success: false,
        error: 'You do not have permission to delete this subscription'
      });
    }
    
    // Delete subscription
    await subscription.destroy();
    
    res.status(200).json({
      success: true,
      message: 'Alert subscription deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting alert subscription:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get inventory data source for reports/widgets
exports.getInventoryDataSource = async (req, res) => {
  try {
    const { metric, categoryId, period } = req.query;
    const inventoryIntegration = require('./integrations/inventory');
    
    let data;
    switch(metric) {
      case 'assetsByCategory':
        data = await inventoryIntegration.getAssetCountsByCategory();
        break;
      case 'assetsByStatus':
        data = await inventoryIntegration.getAssetCountsByStatus();
        break;
      case 'assetsByHealth':
        data = await inventoryIntegration.getAssetsByHealthStatus();
        break;
      case 'assetsApproachingEOL':
        data = await inventoryIntegration.getAssetsApproachingEOL(parseInt(period) || 6);
        break;
      case 'assetUtilization':
        data = await inventoryIntegration.getAssetUtilization(
          req.query.assetId || null,
          parseInt(period) || 30
        );
        break;
      case 'assetValueDistribution':
        data = await inventoryIntegration.getAssetValueDistribution();
        break;
      default:
        data = { message: 'Invalid metric specified' };
    }
    
    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    console.error('Error getting inventory data source:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get warehouse data source for reports/widgets
exports.getWarehouseDataSource = async (req, res) => {
  try {
    const { metric, category, itemId, dateRange, startDate, endDate } = req.query;
    
    // Format date parameters
    const dateParams = {
      dateRange: dateRange || 'month',
      startDate: startDate ? new Date(startDate) : null,
      endDate: endDate ? new Date(endDate) : null
    };
    
    // This would normally use the warehouse integration
    // For now we'll simulate it with basic warehouse report generation
    let data;
    switch(metric) {
      case 'inventoryLevels':
        data = await generateWarehouseReport(
          { reportType: 'inventory_levels' }, 
          { category, orderBy: req.query.orderBy }
        );
        break;
      case 'stockMovements':
        data = await generateWarehouseReport(
          { reportType: 'stock_movement' }, 
          { 
            ...dateParams,
            itemId,
            movementType: req.query.movementType
          }
        );
        break;
      case 'lowStockItems':
        data = await generateWarehouseReport(
          { reportType: 'low_stock' }, 
          { category }
        );
        break;
      default:
        data = { message: 'Invalid metric specified' };
    }
    
    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    console.error('Error getting warehouse data source:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get service management data source for reports/widgets
exports.getServiceDataSource = async (req, res) => {
  try {
    const { metric, priority, period, startDate, endDate } = req.query;
    const serviceIntegration = require('./integrations/service');
    
    // Format date parameters
    const start = startDate ? new Date(startDate) : null;
    const end = endDate ? new Date(endDate) : null;
    
    let data;
    switch(metric) {
      case 'incidentsByStatus':
        data = await serviceIntegration.getIncidentCountsByStatus(start, end);
        break;
      case 'incidentsByPriority':
        data = await serviceIntegration.getIncidentCountsByPriority(start, end);
        break;
      case 'resolutionTimeStats':
        data = await serviceIntegration.getIncidentResolutionTimeStats(priority);
        break;
      case 'slaCompliance':
        data = await serviceIntegration.getSLAComplianceStats(
          req.query.groupBy || 'month',
          parseInt(period) || 12
        );
        break;
      case 'maintenanceStats':
        data = await serviceIntegration.getMaintenanceStats();
        break;
      case 'knowledgeBaseStats':
        data = await serviceIntegration.getKnowledgeBaseStats();
        break;
      case 'topIncidentCategories':
        data = await serviceIntegration.getTopIncidentCategories(parseInt(req.query.limit) || 10);
        break;
      default:
        data = { message: 'Invalid metric specified' };
    }
    
    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    console.error('Error getting service data source:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get requests data source for reports/widgets
exports.getRequestsDataSource = async (req, res) => {
  try {
    const { metric, requestType, period, startDate, endDate } = req.query;
    const requestsIntegration = require('./integrations/requests');
    
    // Format date parameters
    const start = startDate ? new Date(startDate) : null;
    const end = endDate ? new Date(endDate) : null;
    
    let data;
    switch(metric) {
      case 'requestsByStatus':
        data = await requestsIntegration.getRequestCountsByStatus(start, end);
        break;
      case 'requestsByType':
        data = await requestsIntegration.getRequestCountsByType(start, end);
        break;
      case 'processingTimeStats':
        data = await requestsIntegration.getRequestProcessingTimeStats(requestType);
        break;
      case 'requestsByDepartment':
        data = await requestsIntegration.getRequestsByDepartment(start, end);
        break;
      case 'requestTrends':
        data = await requestsIntegration.getRequestTrends(
          req.query.groupBy || 'month',
          parseInt(period) || 12
        );
        break;
      default:
        data = { message: 'Invalid metric specified' };
    }
    
    res.status(200).json({
      success: true,
      data
    });
  } catch (error) {
    console.error('Error getting requests data source:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};
